#' Generate random N-dimensional clusters based on mean and SD
#'
#' @param k     Number of clusters
#' @param d     Dimensions of the cluster points
#' @param nump  A single number denoting number of points in each cluster, or a vector of values denoting number of points in each cluster
#' @param m1    A (k x d) matrix of mean of the points in each cluster for each dimension
#' @param m2    A (k x d) matrix of SD of points in each cluster for each dimension
#' @return A matrix of d columns

clusters.generate <- function(k, d, nump, m1, m2) {
  
  ## Do param validation here
  if (length(nump) < k) {
    if (length(nump) == 1) {
      nump <- rep(nump, k)
    }
    else {
      print(paste("Length of vector nump is not consistent with number of clusters (k)"))
    }
  }
  
  matrixInitialized = FALSE
  for (i in 1:d) {  # Generate a 
    x <- c()
    
    for (j in 1:k) {
      x <- c(x, rnorm(nump[j], m1[j, i], m2[j, i]))
    }
    
    if (matrixInitialized == FALSE) {
      m <- matrix(x, length(x), 1)
      matrixInitialized = TRUE
    }
    else {
      m <- cbind(m, x)
    }
  }
  
  randomizer <- order(runif(sum(nump), 0, 100))
  m <- m[randomizer, ]
  return(m)
  
}

#' 2-D plotting of clusters generated by G-means
#'
#' @param data     A data frame or matrix with each row representing an individual observation
#' @param clusters The cluster vector from the output of Gmeans on the data 
# Assumes data is N x 2 matrix
clusters.plot.2D <- function(data, clusters) {
  if (nrow(data) != length(clusters))
    stop("Data and clusters vector should be of same length")
  
  plot(data)
  df <- as.data.frame(cbind(data, clusters))
  names(df) <- c("1", "2", "clusters")
  
  for (i in unique(df$clusters)) {
    cluster <- subset(df, clusters == i, select = c("1", "2"))
    ellipse(mu=colMeans(cluster), sigma=cov(cluster), alpha=0.05, npoints=nrow(cluster), col="red")
  }
}